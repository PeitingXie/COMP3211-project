

Tag generation example


    ins memory

        pre-defined(registers) :
            0 : D0
            1 : D1
            2 : D2
            3 : D3
            4 : tag
            10 : 0
        start :
             // will change after swap and rotate, to generate tag
            sw 20, $0, 0, store D0 in data memory 20
            sw 21, 0, 1, store D1 in data memory 21
            sw 22, 0, 2, store D2 in data memory 22
            sw 23, 0, 3, store D3 in data memory 23
            // backup record, won't change
            sw 24, $0, 0, store D0 in data memory 20
            sw 25, 0, 1, store D1 in data memory 21
            sw 26, 0, 2, store D2 in data memory 22
            sw 27, 0, 3, store D3 in data memory 23

            // decode secret
            lw $5, $10, 9  load secret in $5

            lw $15, $10, 110    load 10 into $15 
            lw $14, $10, 3     get 0b111, store in $14
            srr $6, $5, $15
            and $6, $6, $14    
            lw $6, $6, 0      get size, store in $6

            lw $15, $10, 2    get 0b11, store in $15
            and $7, $5, $15    get b1, store in $7

            lw $15, $10, 104  get 4, store in $15
            srr $8, $5, $15  
            and $8, $8, $14    get p1, store in $8
            lw $9, $7, 20      get b1 related block, store in $9
            srr $9, $9, $8     shift b1 block for p1 bits
            and $11, $9, $6    get given size of bits in block b1, ready for swap, store in $11

            lw $12, $10, 102    get value 2, store in $7
            srr $12, $5, $12    
            lw $15, $10, 2    get 0b11, store in $15
            and $12, $12, $15   get b2, store in $12
            lw $15, $10, 107    get 7, store in $15
            srr $13, $5, $15  
            and $13, $13, $14   get p2, store in  $13
            lw $14, $12, 20     get b2 related block, store in $14
            srr $14, $14, $13   
            and $15, $14, $6    get given size of bits in block b2, ready for swap, store in $15

            lw $14, $10, 110
            srr $14, $5, $14  
            lw $9, $10, 3     get 0b111, store in $9 
            and $14, $14, $9 ----  get size in decimal

            lw $9, $7, 20      get b1 related block, store in $9


            add $0, $8, $14
            srr $1, $9, $0     
            sll $1, $1, $0       get bits left from p1 + s, shift to right position, store in $1    

            lw $0, $8, 0        get transfer x as binary, store in $0 for example, if p1 is 3, we will load ob111 into $0
            and $0, $9, $0      get bits right from bit p1, store in $0
            sll $2, $15, $8
            add $3, $0, $1
            add $3, $3, $2
            sw $3, $7, 20       get first record after swap, store in related position in data memory

            lw $9, $12, 20
            add $0, $13, $14
            srr $1, $9, $0
            sll $1, $1, $0      get bits left from p2 + s, shift to right position, store in $1 

            lw $0, $13, 0
            and $0, $9, $0
            sll $2, $11, $13
            add $3, $0, $1
            add $3, $3, $2
            sw $3, $12, 20    get second record after swap, store in related position in data memory

            ------------
            finished swap, store in 20-23 in data memory
            ------------

            lw $0, $10, 20   get D0 after swap, store in $0
            lw $1, $10, 113     get 13, store in $1
            srr $1, $5, $1
            lw $2, $10, 3       get 0b111, store in $2
            and $3, $2, $1      get r0, store in $3

            slr $0, $0, $3
            sw $0, $10, 20      
            ---------------
            finish rotate D0, store in data memory 20
            ---------------
            lw $0, $10, 21      get D1 after swap, store in $0
            lw $1, $10, 116     get 16, store in $1
            srr $1, $5, $1  
            and $3, $2, $1      get r1, store in $3

            slr $0, $0, $3
            sw $0, $10, 21      

            ---------------
            finish rotate D1, store in data memory 21
            ---------------

            lw $0, $10, 22      get D2 after swap, store in $0
            lw $1, $10, 119     get 19, store in $1
            srr $1, $5, $1  
            and $3, $2, $1      get r2, store in $3

            slr $0, $0, $3
            sw $0, $10, 22     

            ---------------
            finish rotate D2, store in data memory 22
            ---------------

            
            lw $0, $10, 23      get D3 after swap, store in $0
            lw $1, $10, 122     get 22, store in $1
            srr $1, $5, $1  
            and $3, $2, $1      get r3, store in $3

            slr $0, $0, $3
            sw $0, $10, 23   
            ---------------
            finish rotate D3, store in data memory 23
            ---------------

            lw $0, $10, 20
            lw $1, $10, 21
            lw $2, $10, 22
            lw $3, $10, 23

            xor $0, $0, $1
            xor $0, $0, $2
            xor $0, $0, $3
            
            sw $0, $10, 150  ----- store generated tag in data memory 150
            beq $0, $4, 1       if valid tag, jump next instruction
            beq $0, $0, 100      jump calculation
            lw $0, $10, 5       get 0b11111, used for get district number, store in $0
            lw $1, $10, 103    get 3, store in $1
            lw $2, $10, 24      get unchanged D0
            srr $13, $$2, $1 
            and $13, #13, $0   get district number, store in $13
            
            lw $0, $10, 3       get 0b111, store in $0
            and $3, $2, $0      get last three bits in D0, store in $3


            lw $2, $10, 25      get unchanged D1, store in $2
            lw $0, 10, 1        get 1, store in $0
            lw $1, $10, 107     get 7, store in $1
            lsr $4, $2, $1
            and $4, $4, $0      get first bit in D1, store in $4
            srl $3, $3, $0
            add $14, $3, $4     store candicate number in $14     

            lw $0, $10, 7
            and $0, $2, $0      D1 last 7 bits, store in $0
            lw $1, $10, 26      D2 all bits, store in $1
            lw $2, $10, 27      D3 all bits, store in $2
            lw $3, $10, 116     get 16, store in $3
            slr $0, $0, $3      
            lw $4, $10, 108
            slr $1, $1, $4
            add $15, $0, $1
            add $15, $15, $2

            -------
            get District number, store in $13
            get candicate number, store in $14
            get Vote number, store in $15
            data memory 12 : 0xff (curr candicate number)
            data memory 13 : 0 (next position)
            14 : 0 : (total votes for curr candicate)
            -------
            lw $0, $10, 12
            beq $0, $14, 4          if same candicate
            nops
            nops
            beq $0, $0, 11          if not same candicate,
            nops
            nops
            lw $0, $10, 13
            lw $1, $10, 14
            add $1, $1, $15         update total votes
            sw $1, $10, 14          set new total votes to data memory 14
            add $0, $0, 1           add next position by 1
            sw $15, $0, 0           store votes for this district
            sw $0, $10, 13          store next position back
            
            beq $0, $0, 30
            nops
            nops   
            lw $0, $10, 13      get next position, store in $0
            lw $1, $10, 14      get total votes for last candicate, store in $1
            add $0, $0, 1       add position by 1
            sw $1, $0, 0        store total count
            add $0, $0, 1       add position by 1
            sw $14, $0, 0       store new candicate name
            sw $14, $10, 12     update curr candicate number
            sw $15, $10, 14
            sw $0, $10, 13          store next position back







            











            
      













    data memory
    0 : 0 
    1 : 1
    2 : 3
    3 : 7
    4 : 15 
    5 : 31
    6 : 63
    7 : 127
    8 : 255
    9 : secret ( 25 bit)
    100 : 0
    101 : 1
    102 : 2
    103 : 3
    104 : 4
    105 : 5
    106 : 6
    107 : 7
    108 : 8
    109 : 9
    110 : 10
    111 : 11
    112 : 12
    113 : 13
    114 : 14
    115 : 15
    116 : 16
    117 : 17
    118 : 18
    119 : 19
    120 : 20
    121 ï¼›21
    122 : 22
    123 : 23
    124 : 24
    




    after tag generate : 
    $15 store vote number
    $14 store cand number
    $13 store district number

    data memory 12 : 0xff (curr candidate number)
    data memory 13 : 0 (next position)
    14 : 0 : (total votes for curr candidate)




    assume other candidate record will only come when all previous candidate record is calculated 
    it should looks like
    candidate 1:
        vote number 1
        vote number 2
        ...
        total number
    candicate 2:
        .....



    pre-defined :
        get District number, store in $13
        get candidate number, store in $14
        get Vote number, store in $15
        data memory 12 : 0xff (curr candidate number)
        data memory 13 : 1e (next store position)
        data memory 14 : 0 : (total votes for curr candidate)
    Pseudocode :
        if tag is true :
            if candidate in record == candidate in data memory :
                add total vote number
                get position in table called p
                store this record's vote number in table position p
                p += 1
                store p back to data memory
            else
                get position in table called p
                store total vote count in table position p
                p += 1
                replace candidate in data memory by candidate in record
                store candidate numver in record in table position p
                p += 1
                replace total value in data memory by this record's vote number
                store this record's vote number in table position p
                p += 1
                store p back to data memory
    